#!/usr/bin/env php
<?php

/**
 * PHPX Build Tools CLI
 *
 * Main entry point for PHPX build commands
 */

// Find autoloader
$autoloadPaths = [
    __DIR__ . '/../vendor/autoload.php',
    __DIR__ . '/../../../autoload.php',
];

$autoloaderFound = false;
foreach ($autoloadPaths as $file) {
    if (file_exists($file)) {
        require_once $file;
        $autoloaderFound = true;
        break;
    }
}

if (!$autoloaderFound) {
    fwrite(STDERR, "Error: Composer autoloader not found.\n");
    fwrite(STDERR, "Please run 'composer install' first.\n");
    exit(1);
}

// Determine project root (where composer.json is)
$projectRoot = getcwd();
while (!file_exists($projectRoot . '/composer.json') && $projectRoot !== '/') {
    $projectRoot = dirname($projectRoot);
}

if ($projectRoot === '/') {
    fwrite(STDERR, "Error: Could not find project root (no composer.json found).\n");
    exit(1);
}

// Get command
$command = $argv[1] ?? 'help';
$options = array_slice($argv, 2);

// Parse global flags
$devMode = false;
$htmlMaps = false;
foreach ($options as $option) {
    if ($option === '--dev' || $option === '--development') {
        $devMode = true;
    } elseif ($option === '--create-html-maps') {
        $htmlMaps = true;
    }
}

// Colors for output
define('COLOR_GREEN', "\033[0;32m");
define('COLOR_BLUE', "\033[0;34m");
define('COLOR_YELLOW', "\033[1;33m");
define('COLOR_RED', "\033[0;31m");
define('COLOR_RESET', "\033[0m");

function success($message) {
    echo COLOR_GREEN . "✓ " . $message . COLOR_RESET . "\n";
}

function error($message) {
    fwrite(STDERR, COLOR_RED . "✗ " . $message . COLOR_RESET . "\n");
}

function info($message) {
    echo COLOR_BLUE . "ℹ " . $message . COLOR_RESET . "\n";
}

function warning($message) {
    echo COLOR_YELLOW . "⚠ " . $message . COLOR_RESET . "\n";
}

// Set environment variables for child processes
if ($devMode) {
    putenv('PHPX_DEV_MODE=1');
    info("Development mode enabled (AI source maps will be generated)");
}

if ($htmlMaps) {
    putenv('PHPX_HTML_MAPS=1');
    info("HTML source maps enabled (data-phpx-source attributes will be added)");
}

// Command routing
switch ($command) {
    case 'build':
        info("Running full build (pack + export)...");

        // Run pack
        $packScript = __DIR__ . '/../scripts/wasm-pack.php';
        passthru("php " . escapeshellarg($packScript), $packStatus);

        if ($packStatus !== 0) {
            error("Pack failed with status $packStatus");
            exit($packStatus);
        }

        // Run export
        $exportScript = __DIR__ . '/../scripts/wasm-export.php';
        passthru("php " . escapeshellarg($exportScript), $exportStatus);

        if ($exportStatus !== 0) {
            error("Export failed with status $exportStatus");
            exit($exportStatus);
        }

        success("Build completed successfully!");
        break;

    case 'pack':
        info("Running pack...");
        $packScript = __DIR__ . '/../scripts/wasm-pack.php';
        passthru("php " . escapeshellarg($packScript), $status);
        exit($status);

    case 'export':
        info("Running export...");
        $exportScript = __DIR__ . '/../scripts/wasm-export.php';
        passthru("php " . escapeshellarg($exportScript), $status);
        exit($status);

    case 'watch':
        info("Starting watch mode...");
        $watchScript = __DIR__ . '/../scripts/wasm-watch.sh';

        // Check if watch script is executable
        if (!is_executable($watchScript)) {
            chmod($watchScript, 0755);
        }

        // Pass --dev flag to watch script if in dev mode
        $devFlag = $devMode ? ' --dev' : '';
        passthru("bash " . escapeshellarg($watchScript) . $devFlag, $status);
        exit($status);

    case 'serve':
        // Parse options
        $requestedPort = null; // Will be set if --port is explicitly provided
        $publicDir = 'public'; // Default public directory (relative to project root)

        foreach ($options as $option) {
            if (preg_match('/^--port=(\d+)$/', $option, $matches)) {
                $requestedPort = (int)$matches[1];
            } elseif (preg_match('/^--public=(.+)$/', $option, $matches)) {
                $publicDir = $matches[1];
            }
        }

        // Resolve public directory path (support both relative and absolute paths)
        if (!str_starts_with($publicDir, '/')) {
            $publicDir = $projectRoot . '/' . $publicDir;
        }

        // Normalize path
        $publicDir = rtrim($publicDir, '/');

        if (!is_dir($publicDir)) {
            error("Public directory not found: $publicDir");
            exit(1);
        }

        // Function to check if a port is available
        $isPortAvailable = function($port) {
            $connection = @fsockopen('localhost', $port, $errno, $errstr, 1);
            if ($connection) {
                fclose($connection);
                return false; // Port is in use
            }
            return true; // Port is available
        };

        // Find an available port
        $port = null;
        if ($requestedPort !== null) {
            // User explicitly requested a port, use it without checking
            $port = $requestedPort;
            info("Using explicitly requested port: $port");
        } else {
            // Auto-detect available port starting from 9999
            $startPort = 9999;
            $maxAttempts = 20;

            for ($i = 0; $i < $maxAttempts; $i++) {
                $tryPort = $startPort - $i;
                if ($isPortAvailable($tryPort)) {
                    $port = $tryPort;
                    if ($i > 0) {
                        info("Port $startPort was busy, using port $port instead");
                    }
                    break;
                }
            }

            if ($port === null) {
                error("Could not find an available port after $maxAttempts attempts (tried $startPort down to " . ($startPort - $maxAttempts + 1) . ")");
                exit(1);
            }
        }

        info("Starting development server on http://localhost:$port");
        info("Document root: $publicDir");
        info("Press Ctrl+C to stop the server");
        echo "\n";

        // Start PHP built-in server
        passthru("php -S localhost:$port -t " . escapeshellarg($publicDir), $status);
        exit($status);

    case 'help':
    case '--help':
    case '-h':
        echo <<<HELP
PHPX Build Tools - Build system for PHPX WebAssembly projects

Usage:
  phpx-build <command> [options]

Commands:
  build     Full build (pack + export)
  pack      Pack only (compile and bundle)
  export    Export only (copy artifacts to public)
  watch     Watch mode with auto-rebuild
  serve     Start development server
  help      Show this help message

Options:
  --dev             Enable development mode (generates AI source maps for debugging)
  --create-html-maps Add source location metadata to HTML elements (data-phpx-source attributes)
  --port=<port>     Server port (default: auto-detect from 9999, serve command only)
  --public=<dir>    Public directory to serve (default: public, serve command only)
  --help, -h        Show help message

Examples:
  phpx-build build                     # Production build
  phpx-build build --dev               # Development build with AI source maps
  phpx-build build --create-html-maps  # Build with HTML source maps
  phpx-build build --dev --create-html-maps  # Both AI and HTML source maps
  phpx-build watch                     # Watch mode (production)
  phpx-build watch --dev               # Watch mode with AI debugging
  phpx-build pack                      # Pack only
  phpx-build serve                     # Start dev server (auto-detect port from 9999)
  phpx-build serve --port=8080         # Start dev server on specific port
  phpx-build serve --public=dist       # Serve from 'dist' directory
  phpx-build serve --port=3000 --public=build  # Custom port and directory

For more information, visit:
  https://github.com/syntaxx/phpx-build-tools

HELP;
        exit(0);

    case 'version':
    case '--version':
    case '-v':
        $composerJson = json_decode(file_get_contents(__DIR__ . '/../composer.json'), true);
        $version = $composerJson['version'] ?? 'dev-main';
        echo "PHPX Build Tools version " . $version . "\n";
        exit(0);

    default:
        error("Unknown command: $command");
        echo "Run 'phpx-build help' for usage information.\n";
        exit(1);
}
